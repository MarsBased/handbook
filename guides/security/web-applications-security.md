TODO: Add Remix and/or Express implementations equivalent to the Rails ones.
TODO: Write TOC

# Web applications security

It is crucial to keep the web applications we work on as secure as possible. Even the smallest vulnerability, if exploited in the right way, can be disastrous for a client. Therefore, applying good security practices to the web applications we develop for clients (and even internal applications for MarsBased) is of the utmost importance.

## Security features

The following security features should be applied to any project we work on:
* No credentials in code. No credentials in generated artifacts.
* Force HTTPS traffic.
* Use secure and encrypted Cookies.
* Protect against Cross-Site Request Forgery (CSRF).
* Implement a strict Content Security Policy (CSP).
* Disallow redirecting the user to arbitrary domains.
* Avoid logging sensitive data

The Tech Lead or Project Manager of each project should talk to the client to encourage their implementation, citing the importance for having a minimizing the risk of the application getting exploited.

Of course, there are cases where having a secure application is less or more important. Sometimes a compromise will need to be reached, and implement only the most critical features. For example, an internal application that is not exposed to the public and which does not store sensitive data is not the same as a public facing application storing medical records.

### No credentials in code. No credentials in generated artifacts.

Make sure there are no hardcoded credentials in the code. These include passwords, API keys, certificates, etc.

Use environment variables or other means to store credentials and retrieve them during application runtime. In Rails, you may also use [encrypted credentials](https://edgeguides.rubyonrails.org/security.html#environmental-security).

Make sure there are no credentials in artifacts generated by the application. The most common scenario is inadvertently including credentials in Docker images. But it can also happen in mobile or desktop application builds.

#### Credentials in Docker images

Even if there are no hardcoded credentials in the code, you will most probably have local gitignored files with real credentials. For example you might have `.env` file with credentials, or `secrets.yml` files used by Kubernetes.

When generating Docker images for deployment, is common to have a `COPY . .` statement in the Dockerfile. This copies everything in the application directory, including any gitignored file we might have with production credentials.

To prevent these sensitive files from being included, create a `.dockerignore` file listing all of them.

### Force HTTPS traffic

Any unencrypted traffic request (HTTP) arriving to the application is vulnerable to being read by an attacker. For example, a login request sent through HTTP includes the password in plain text. Anyone listening to the network can see the request and steal the password.

Therefore it's crucial to make sure all traffic arrives to the application via HTTPS. Use the following rules:
* Redirect all HTTP request to HTTPS.
* Send [HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) headers. This makes sure that browser can only interact with the application using HTTPS.

#### Implementation

* Rails: Add `config.force_ssl = true` to `config/environments/production.yml` and any other non-development environment.
* Others: Manually add the HSTS header to all server responses: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`

### Use secure and encrypted session cookies

It is common to store the user sessions in Cookies. Make sure the session cookie is marked as secure.

Secure cookies are only sent with HTTPS requests. This prevents these cookies from being read by an attacker in the event of sending an HTTP request.

#### Implementation

* Rails: Add `config.force_ssl = true` to `config/environments/production.yml` and any other non-development environment. Rails encrypts session cookies by default.
* Others: Add the `Secure` attributes to the session cookie. Encrypt/Decrypt the session cookie in the server using a generated secret key.

### Protect against Cross-Site Request Forgery (CSRF)

CSRF consist on making a user inadvertently execute an authenticated request to an application where she is logged in.

It's better explained with an example:

Let's imagine a user is an administrator in https://yourapp.com. And he has an active session in the site. The user browses a message board where an attacker has crafted a message that contains a fake img HTML element:

```
<img src="https://yourapp.com/admin/admin_users/create?[...]">
```

If the `/admin/admin_users/create` endpoint does not have CSRF protection, when the user loads this message the request will be executed. Since the user is authenticated, it will create a new admin user. The attacker can now use this admin user to access the administration panel of https://yourapp.com

In most cases, such an endpoint will not accept a GET request. An attacker can still send a POST request using for example the `mouseover` attribute of the `img` element with something like this:

```
<img src="https://imagebank.com/someimage" mouseover="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'https://yourapp.com/admin/admin_users/create';
  f.submit();
  return false;" />
```

If the message board does not have proper XSS protection, the request will be executed.

#### Mitigation

CSRF attacks are commonly mitigated by requiring all non-GET requests to include a CSRF token. This token is randomly generated by the server, so it's impossible for an attacker to guess it or generate it.

Usually its accomplished by including a hidden input in all forms rendered by the application. Example:

```
<input type="hidden" name="authenticity_token" value="Z-L3yUHAosQMW0OXMdMveWCIeODeCcXo419zpuUhBBUge9y5-aWZ4GUGFnZmoKNQa3shS8VlSTZuRG8q_ALpvA">
```

The value is randomly generated by the server.

Then, server side, we check the token against a token saved in the user session for instance.

For AJAX request, if we can't include the token as a parameter, a common approach is take it from a `meta` tag in the page and send it with a header with every request. This is a simple example with jQuery to include the header in every AJAX request:

```

$(document).ready(
  function() {
    var csrfToken = $('meta[name="csrf-token"]').attr('content');
    if (csrfToken) {
      $.ajaxSetup({
        headers: {'X-CSRF-Token': csrfToken}
      });
    }
  }
)
```

#### Implementation

* Rails: Rails includes CSRF protection by default. Everything is taken care by the framework automatically.
* Remix: ?
* ExpressJS: ?

### <a name="csp">Implement a strict Content Security Policy (CSP)</a>

CSP is the best protection you can implement against [XSS attacks](#xss) (and many other attack methods). It consists on telling the browser the trusted sources from where to allow external resources (scripts, stylesheets, audios, videos, etc.).

It is implemented by sending a `Content-Security-Policy` header in server responses with a policy definition. The policy specifies in as much detail as wanted the allowed sources for each type of resource. The full reference can be found in the [MDN page](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).

Ideally, you should write a different CSP policy per page, because not all pages need to load the same resources. At least, you should do it for each application scope. For example, the admin panel probably does not need to allow the same sources as the landing page.

The key points to consider when implementing a strict CSP policy are:
* Completely disallow any resource type that's not used in the page. `object-src` (`<object>`, `<embed>`, and `<applet>`), `child-src` (web workers and `<iframe>`), `frame-src` (`<iframe>`), `media-src` (`<audio>`, `<video`), `worker-src` are pretty common resource types to disable. Use the `'none'` value for those.
* For the ones you need to allow: write a policy as strict as possible. Start by allowing only loading from the same origin (`'self'` value) and add more trusted hosts if necessary.
* Avoid adding the `https:` value. This would allow resources to be loaded from any origin. When you need to load from external sources list them individually Read below for a more detailed explanation.

#### Loading scripts and other resources from external origins

You most probably need to load scripts from Google, Facebook and other analytics services, or images from a CDN.

In that case list the origins one by one. For example:

```
Content-Security-Policy: [...] script-src 'self' *.facebook.net www.google-analytics.com; img-src 'self' mycdn.myapp.com; [...]
```

**NOTE**: If you are using Google Tag Manager, some script might be dynamically included in the page. It is important to figure out the scripts added this way to allow the appropriate origins. You can use [Violation reporting](#violation-reporting) to discover some unknown scripts being added.

#### Loading inline scripts

Often, you will need to allow inline `<script>` elements because you are using them yourself to build some functionality on a page, or to pass some data from the server to a Javascript process.

In this case, make use of nonces. Instead of using `unsafe-inline` to allow inline script, use `nonce-*`. This value allows inline script but **only if they include the same nonce value you have specified in the policy**. For example, the following policy:

```
Content-Security-Policy: [...] script-src 'self' 'nonce-1234567890abcde'; [...]
```

Will only allow scripts to be executed on the page if they include the nonce:

```
<script nonce="1234567890abcde">
  console.log('hello')
</script>
```

This makes it possible to make use of our own inline scripts on the page while making it impossible to execute malicious `<script>` forged by attackers.

#### Violation reporting

CSP includes a feature to get alerted of all violations. That is, when a resource can't be loaded due to a CSP policy. This is a great tool, not only to be aware of errors users might be facing, but also to initially discover all external resources being loaded when initially building a set of policies for an application.

A common approach to use when adding CSP to an existing application is to enable it only in reporting mode, gather all the resources for some time and then build the policies.

Adding a reporting URL only requires adding `report-uri https://myapp.com/csp_violation` to the header. You can find more details in the [MDN site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#reporting_directives).

#### Implementation

* Rails: Starting from version 6, Rails includes CSP protection by default. It has a default policy at allows to tune it according to the needs of each application.

### Disallow redirecting the user to arbitrary domains.

Be careful when using user supplied parameters or other user inputted data to redirect the user. A common vulnerability is to use a `redirect_to` query parameter in a login request to redirect the user to a specific page after login.

Without validation the value of the `redirect_to` parameter, we are giving the ability for anyone to craft a login link that will redirect to another site. Always validate the parameter to make sure it's just a URL path without host.

### Avoid logging sensitive data

Make sure you are not writing any sensitive data to logs. These include user passwords, api tokens, nonces, etc.

For example, a login request will probably log the e-mail and password parameters. The password parameter should be filtered or removed to avoid it being written to the logs.

#### Implementation

* Rails: Rails already filters the most common parameters by default. You can instruct Rails to filter other parameters with the `config.filter_parameter_logging` configuration option.

## Protect against other attack vectors

There are multiple ways a web application can be exploited. These are some of the most common attack vector your application should be protected from:
* Protect against Cross-Site Scripting (XSS).
* Protect against SQL Injection.
* Protect against Headers injection.
* Protect against Session Fixation.

### <a name="xss">Protect against Cross-Site Scripting (XSS)</a>

Cross-Site Scripting, most commonly known simply as XSS, is one of the most prominent attack methods on web applications.

It consists on injecting an arbitrary script on a page. When another user is browsing the page, it will execute the script. The script could do anything: modify the user cookies, trigger a request on the user behalf, copy some sensitive date and send it elsewhere, redirect to the user to another site, etc.

Any element on a page that renders user input data is susceptible of being vulnerable to XSS attacks.

#### Mitigation

There is no single technique to protect against XSS. Protection is achieved by following some best practices.
* HTML-escape all user input: replace the HTML input characters &, ", <, and > by their uninterpreted representations in HTML (`&amp;`, `&quot;`, `&lt;`, and `&gt;`)
* When we want to allow the user to input HTML and show it on the page: sanitize the HTML. Use a white-listing technique to only allow a handful of safe HTML tags: `<p>`, `<span>`, `<b>` , `<i>`, etc. And equally important: sanitize all attributes on these tags. Only allow a handful of safe attributes: `class`, `id`, etc. If you need to allow `style` attributes for example, make sure to properly sanitize them. They can be used to perform [CSS injection attacks](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/11-Client_Side_Testing/05-Testing_for_CSS_Injection).
* On the front-end side, avoid rendering user-input as HTML. Avoid the usage of jQuery's `html()` as much as possible. Use `text()` instead. Similarly avoid user `innerHTML = ` unless you are sure the content is properly sanitized.
* Implement a strict [Content Security Policy (CSP)](#csp)

### Protect against SQL Injection

SQL injection is another common way of attacking a web application. It consists on exploiting a database query that interpolates user input data without sanitizing it. It gives an attacker the chance to execute any arbitrary query on the database.

#### Mitigation

Make sure to always sanitize user inputted data before using them in a query. The specific details of how to do it depend on each database engine. However, you will rarely need do this manually. Most ORM framework protect against SQL injection by default, when used in the right way.

Another measure that can help lower the impact of an SQL injection attack, in the event of happening, is to restrict as much as possible the permissions of the database user being used by the application.

### Protect against Headers injection.

When using the values of HTTP headers in your application, take into account that headers can be easily modified by an external party.

A common case is an application that uses the `Host` header to render URLs in the page or in e-mails. Since the `Host` header can be manipulated to contain a malicious hostname, the application might be including links to the malicious site.

Another less common but very dangerous scenario is when including a request parameter or other user inputted data in a header. The user could introduce a carriage return to include any other header in the request or even two carriage requests to send an arbitrary response, hiding the real response from the server. [The Rails security guide](https://edgeguides.rubyonrails.org/security.html#header-injection) is a great resource to find more details on these type of attack.

#### Mitigation

Always validate or sanitize the value of the headers before using them in a way that can be harmful for the application or the user.

Most web application frameworks include a set of default measures to prevent header injection attacks. But you still need to be diligent when modifying the value of response headers or including your own headers.

### Protect against Session Fixation

Session Fixation is a type of attack that only affects applications that store the user session in the database.

The common way to execute it is by exploiting an XSS vulnerability. The attacker injects a script that modifies the session ID stored in the cookies, by replacing it with the same session ID that the attacker is using.

This forces the user to log-in again. When done so, both the user and the attacker will be logged in as the user.

#### Mitigation

When storing sessions in the database, always reset the session after every login. This will generate a new ID and invalidate the malicious ID that the attacker injected.

#### Implementation

* Rails: Call the `reset_session` method after login. When using `Devise` this is done automatically.

## Protect the admin panel

Most applications have an administration panel. The administration panel is the most sensitive part of an application because it usually allows to perform all sorts of actions and modifications that regular users can't do.

Therefore it's critical to protect it properly:
* It is strongly recommended to make [Two-Factor authentication](./personal-security.md#two-factor-authentication) mandatory for all admin users.
* Consider hiding the admin panel behind a VPN. Only users connected to the VPN will be able to open the admin panel.
* Consider hosting the admin panel in a subdomain different to the public application domain. This alone prevents some forms of attack, like stealing the cookies from the public site to login to the admin panel.
* Considering placing the admin panel in a hard-to-guess path different to `/admin`. And, of course, don't include any reference to it in the `robots.txt` or `sitemap.xml` files.
* Consider adding roles to users with different permission levels. If a user account gets compromised but it only has limited permissions, the harm will be reduced.

## Protect your users

It is also critical to prevent user accounts from being hacked or stolen. There are some factors that the application can control because they depend on the user using secure practices herself. But there are a few security measure an application can implement to reduce the risk to the minimum:
* Consider allowing users to enable [Two-Factor authentication](./personal-security.md#two-factor-authentication). Depending on the sensitivity of the data managed by the application, consider making it mandatory. For example, a banking application should implement mandatory 2FA.
* Require strong and non-exploited passwords. The same [rules that apply for your personal security](./personal-security.md#strong-password) should apply to passwords for the users of your application. Enforce these rules. It's also a good idea to check passwords against a [list of cracked passwords](https://haveibeenpwned.com/API/v3). In Ruby you can use the [pwned gem](https://github.com/philnash/pwned) to do it in a very easy way.
* [Prevent user enumeration attacks](#prevent-user-enumeration-attacks).
* [Prevent brute-forcing passwords](#prevent-brute-forcing-passwords).

### Prevent user enumeration attacks

A user enumeration attack consist on discovering the e-mails of registered users by exploiting a public page that inadvertently exposes such information.

This is commonly found in the sign-in, reset password and sign-up pages. In order to prevent it, the page should show always show the same error message when authentication fails. It does not matter if it failed because the e-mail does not exist, because the password is wrong or because the account is blocked. The user should always receive the same error.

The same rule should be applied to the reset password page. Regardless of whether the introduced e-mail exists or not, we should return the same message to the user.

In sign-up pages it's more tricky to prevent, because we need to let the user know if an e-mail address exists. For such pages, the recommended approach is to require solving a reCAPTCHA after a number of failed attempts.

### Prevent brute-forcing passwords

If an attacker knows or discovers the e-mail address of a registered user, she could use it to guess the password by making continuous login attempts.

In order to prevent such an attack, it's recommended to limit the number of failed login attempts. The limit can be applied per user account or per IP. After the limit is reached, the account/IP is blocked for certain time. A common approach is to use exponential back-off to calculate this time. The first time an account is blocked it will be for 5 minutes, for instance, the second time 15 minutes, the third time 1 hour, etc.

## Cookies best practices

Cookies are stored in the browser. Therefore, they are easily manipulated by the user. Take these precautions when working with cookies:
* Always add the `Secure` flag to cookies. This instructs the browser to only send the cookies to the server when using an HTTPS connection. This avoid these cookies from being read by a third party sniffing the network.
* Encrypt the session cookie. The session cookie is the most sensitive cookies, because it authenticates the user. By encrypting it we prevent it from being read even if a malicious party is able to access it.
* Avoid storing sensitive data in cookies. Use IDs of records stored in the database and fetch those records server-side.
* Similarly, don't rely only on data in the cookies. Always validate it server-side or retrieve it from the database using an ID.

## Security related headers

The following headers protect the application against various attack types. Send them in all server responses unless the application you are working on has some specific needs:

* `X-Frame-Options: SAMEORIGIN`: Allow iframes only on the same domain. **NOTE**: If you are using [CSP](#csp) it might not be necessary. In any case it might still be a good idea to include it for legacy browser that don't support CSP.
* `X-Content-Type-Options: nosniff`: Stops the browser from guessing the MIME type of a file.
* `X-Download-Options: noopen`: Instructs Internet Explorer not to open a download directly.
